#!/usr/bin/env zsh
# vim: ft=sh ts=2 sw=2 et:

# Provides two commands:
# 
# dynexport [var[=val]] ...
# 
#   Behaves like "export" for variables, except also writes the variable to a 
#   global store which is automatically sourced during precmd by all shells. 
#   This allows variables such as session tokens / API keys to be shared across 
#   shells.
#   
#   If =val is absent, the value of 'var' is taken from the shell's current
#   environment. In the var=val form, val may only be scalar. In the 'var'
#   for, val may be non-scalar, however note that non-scalar variables are 
#   always exported to child processes as scalar. In either case, if the value 
#   of 'val' is empty (including if 'var' was unset), the var is removed from 
#   the global store.
#   
#   Parameters considered special by the shell will raise an error and abort.
# 
# dynunset var ...
#   
#   Unsets 'var', and removes it from the global store.

: ${DYNENV_FILE:=$HOME/.dynenv}
: ${DYNENV_FSWATCH:=1}

_dynenv_source() {
  emulate -LR zsh
  [[ -r $DYNENV_FILE ]] && . $DYNENV_FILE
}
autoload -Uz add-zsh-hook
add-zsh-hook precmd _dynenv_source

if (( $DYNENV_FSWATCH && $+commands[fswatch] )); then
  # We do not handle the DYNENV_FILE changing if we're monitoring it.
  typeset -gr DYNENV_FILE
  
  _dynenv_zle_callback() {
    emulate -LR zsh
    if ! read -r -u $1; then
      # If callback was triggered for an empty fd, an error occurred. Detach to
      # avoid busy loop.
      zle -F $1
      exec {1}<&-
      return
    fi
    # If we're not at the prompt, then don't invoke. Dynenv will be sourced
    # on next precmd.
    if zle && [[ $CONTEXT == 'start' ]]; then
      _dynenv_source
    fi
  }
  zle -N _dynenv_zle_callback
  
  () {
    local fd
    exec {fd}< <( fswatch -o $DYNENV_FILE )
    command true  # https://www.zsh.org/mla/workers/2018/msg00966.html
    zle -Fw $fd _dynenv_zle_callback
  }
fi

_dynenv_delete() {
  emulate -LR zsh
  [[ -r $DYNENV_FILE && -w $DYNENV_FILE ]] || return
  # note: sed -i is not portable
  sed "/^unset $1;.*/d" <<EOF >$DYNENV_FILE
$(< $DYNENV_FILE)
EOF
}

dynexport() {
  emulate -LR zsh
  local arg var val interpret
  for arg in $@; do
    if [[ $arg =~ ^[[:alnum:]_]+= ]]; then
      var=${arg%%=*}
      interpret=1
    elif [[ $arg =~ ^[[:alnum:]_]+$ ]]; then
      var=$arg
      interpret=
    else
      >&2 <<< "fatal: unable to parse parameter: $arg"
      return
    fi
    if [[ ${(tP)var} == *special* ]]; then
      >&2 <<< "fatal: cannot set special parameter $var"
      return
    fi
    if (( $interpret )); then
      # Have the shell interpret the assignment so future expansion & typeset
      # dumping works as expected.
      if ! eval "$arg"; then
        >&2 <<< "fatal: bad assignment"
        return
      fi
    fi
    _dynenv_delete $var
    val=${(P)var}
    if [[ -z $val ]]; then
      continue
    fi
    export $var
    local evalstring="unset $var; $(typeset -p $var) # $(date '+%s' 2>/dev/null)"
    eval $evalstring
    >> $DYNENV_FILE <<< $evalstring 
  done
}

dynunset() {
  emulate -LR zsh
  local var
  for var in $@; do
    _dynenv_delete $var
    if [[ ${(tP)var} == *special* ]]; then
      continue
    fi
    unset $var
  done
}
