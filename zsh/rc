# vim: ft=sh ts=2 sw=2 et:

# NOTE: This file (and rc.d/, etc) contain zsh-specific configuration.
# Environment exports are primarily found in profile.d/*.

ZSH=$CONF/zsh

if [[ ! -d $ZSH ]]; then
  print "Warning: zsh config directory not found: $ZSH"
  return
fi

# Entrypoint for profiling
if false; then
  ZSH_PROFILE_STARTUP=1
  zmodload zsh/zprof
fi

# pre.d
# Bootstrap config to be run before anything else is loaded. Ie, make sure
# compinit is initialized before plugins that hook it.
zshrc-pre.d() {
  local f
  for f in $ZSH/pre.d/*(e:'[[ -x $REPLY ]]':onN); . $f
}
zshrc-pre.d
unfunction zshrc-pre.d

# Plugins
# Plain (executable) files in zsh/plugins/ are first-party plugins -- mine.
# Directories are third-party plugins (if they contain a .plugin.zsh file).
# See zsh/functions/zp* for installation helper.
zshrc-plugins() {
  local f name plugins=(
    $ZSH/plugins/*(-.e:'[[ -x $REPLY ]]':onN)
    $ZSH/plugins/*/*.plugin.zsh(-.onN)
  )
  # Build an enclosing function for each so profiling can blame their startup
  # time correctly.
  for f in $plugins; do
    name=${f:t}
    zshrc-plugins:$name() {
      . $f
    }
    zshrc-plugins:$name
    unfunction zshrc-plugins:$name
  done
}
zshrc-plugins
unfunction zshrc-plugins

# User functions & ZLE widgets
# Function and widget definitions are autoloaded if the file is marked 
# executable. If the first line of the file begins with the pattern
# '#*([[:space:]])(fn|zle):', then some actions are taken after auto-loading.
zshrc-getbangactions() {
  emulate -L zsh -o ksh_glob
  local bang
  read -r bang < $2
  if [[ $bang == \#*([[:space:]])${~1}:* ]]; then
    print -- ${=bang#\#*([[:space:]])${~1}:*([[:space:]])}
  fi
}

zshrc-loaduserfns() {
  local f fns=( $1/*(-.e:'[[ -x $REPLY ]]':N) )
  if (( ${#fns} == 0 )); then
    return 1
  fi
  fpath=($1 $fpath)
  for f in $fns; autoload -z ${f:t}
  REPLY=( $fns )
}

zshrc-functions() {
  local fn fname action REPLY
  zshrc-loaduserfns $ZSH/functions || return
  for fn in $REPLY; do
    fname=${fn:t}
    for action in $(zshrc-getbangactions "fn" $fn); do
      case $action in
        nocorrect)
          alias $fname="nocorrect $fname" ;;
        noglob)
          alias $fname="noglob $fname" ;;
        hook=*)
          autoload -Uz add-zsh-hook &&
          add-zsh-hook ${action#hook=} $fname ;;
        reload)
          # Invoke the function to perform initialization
          $fn ;;
        *)
          print "$fname: unknown fn action: $action" >&2 ;;
      esac
    done
  done
}
zshrc-functions
unfunction zshrc-functions

zshrc-widgets() {
  local fn fname action arg REPLY
  zshrc-loaduserfns $ZSH/widgets || return
  for fn in $REPLY; do
    zle -N ${fname::=${fn:t}}
    for action in $(zshrc-getbangactions "zle" $fn); do
      case $action in
        alias=*)
          zle -A $fname ${action#alias=} ;;
        hook=*)
          arg=${action#hook=}
          zle -A $arg ${fname}-hook-$arg
          autoload -Uz add-zle-hook-widget
          quiet add-zle-hook-widget $arg $fname || zle -N $arg $fname ;;
        transform=*)
          zle -T ${action#transform=} $fname ;;
        reload)
          # Invoke the function to perform initialization
          $fn ;;
        *)
          print "$fname: unknown zle action: $action" >&2 ;;
      esac
    done
  done
}
zshrc-widgets
unfunction zshrc-widgets

unfunction zshrc-getbangactions zshrc-loaduserfns

# zshrc.d
# Primary place for zsh config. Load last so that it may make use of plugins.
zshrc-zshrc.d() {
  local f
  for f in $ZSH/rc.d/*(e:'[[ -x $REPLY ]]':onN); . $f
}
zshrc-zshrc.d
unfunction zshrc-zshrc.d

# Stop profiling
if (( $+ZSH_PROFILE_STARTUP )); then
  zprof
fi
