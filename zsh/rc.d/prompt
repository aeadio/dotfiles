# vim: ft=sh ts=2 sw=2 et:

# Prompt formats
() {
  # [[user][@host]:]dir [â¨•gitbranch[:commits][ â‡„ localchanges]]
  # [R ][ðŸ¯Š[â ¶awsprofile ]][â‹®stack]Â» 
  local ps1=(
    $'\n'  # Start with newline for some padding between commands
    '$(ps-basicinfo)'
    '$(ps-directory; ps-git)'
    $'\n'
    '$(ps-ranger)'
    '$(ps-aws)'
    '$(ps-bufstack)'
    '$(ps-caret) '
  )
  
  # [R][ðŸ¯Š[â ¶awsprofile]][â‹®stack]Â» 
  local ps2=(
    '$(ps-ranger)'
    '$(ps-aws)'
    '$(ps-bufstack)'
    '$(ps-caret) '
  )
  
  # ?
  local ps3=( '$(ps-caret "?")' )
  
  # function:linenum @ file:linenum
  # â†’ details
  # Indent by 2 spaces for each execution depth
  local ps4=(
    $'\n'
    '${(pl[${(%):-%e}+1][  ])}'
    '%N:%i @ %x:%I'
    $'\n'
    '${(pl[${(%):-%e}+1][  ])}'
    'â†’ '
  )
  
  # Build prompts from arrays
  setopt prompt_subst
  for i in {1..4}; do
    eval -- "PS$i=\"\${(j::)ps$i}\""
    eval -- "RPS$i=\"\${(j::)rps$i}\""
  done
}


# Info blocks
ps-basicinfo() {
  local user host
  # Username
  # Only show if we've su'd to a user that's out of the ordinary
  if [[ ${(%):-%n} != (a(|nt(|hony(|eadicicco)))|root) ]]; then
    user="%%(!,%B%F{red},%F{cyan})%n%f%b"
  fi
  # Hostname
  # Only show if connected to remote host
  if (( $+SSH_CLIENT || $+SSH_TTY )); then
    host='@%(!,%B%F{yellow},%B%F{magenta})%m%f%b'
  fi
  if [[ -n "$user$host" ]]; then
    print -n "$user$host:"
  fi
}

ps-directory() {
  local maxwidth=$COLUMNS
  local fullpath=${(%):-%~}
  if [[ -n $PS_GIT_HEAD ]] && (( COLUMNS > 15 )); then
    (( maxwidth = COLUMNS >= 120 ? COLUMNS - 40 : COLUMNS / 3 * 2 ))
  fi
  local display=$fullpath
  if (( ${#display} > maxwidth )); then
    # Favor the last components in the path
    # If the first component is '~', always display it
    local components=( ${(s:/:)fullpath} ) pre='/'
    if [[ $components[1] == '~' ]]; then
      components=( $components[2,-1] )
      pre='~/'
    fi
    local n=${#components} npre=${#pre}
    local i rem=$(( maxwidth - npre )) len
    for (( i = n; i > 0; i-- )); do
      len=${#components[$i]}
      if (( rem - len - npre <= 2 )); then
        components[$i]=${(%):-%$(( rem - npre ))<â€¦<$components[$i]%<<}
        break
      else
        (( rem -= len + 1 ))  # count one for the preceding /
      fi
    done
    if (( --i > 0 )); then
      components[$i]='â€¦'
      for (( --i ; i > 0; i-- )); components[$i]=
    fi
    display="$pre${(j:/:):-${=components}}"
  fi
  PS_DIRLEN=${#display}
  print -n "%(!,%F{magenta},%B%F{blue})$display%f%b"
}

ps-git() {
  local branch=$PS_GIT_HEAD commits=$PS_GIT_COMMITS changes=$PS_GIT_CHANGES
  if [[ -z $branch ]]; then
    return
  fi
  local maxsize=$(( COLUMNS - PS_DIRLEN - 1 ))
  if (( maxsize < 4 )); then
    return
  fi
  local invisible='%([BSUbfksu]|([FK]|){*})'
  local lbr=$(( ${#branch} + 1 ))
  local lco=$(( ${#${(S%%)commits//$~invisible/}} + 1 ))
  local lch=$(( ${#${(S%%)changes//$~invisible/}} + 3 ))
  local bsize=$(( maxsize - lco - lch ))
  if (( lbr > bsize )); then
    # If we don't have enough space to show much, elide some portions
    if (( bsize < maxsize / 2 )); then
      changes=
      bsize=$(( maxsize - lco ))
    fi
    if (( bsize < maxsize / 2 )); then
      commits=
      bsize=maxsize
    fi
    branch="%$bsize<â€¦<$branch%<<"
  fi
  print -n " â¨•%(!,%B%F{red},%B%F{cyan})$branch%f%b"
  if [[ -n $commits ]]; then
    print -n ":$commits"
  fi
  if [[ -n $changes ]]; then
    print -n " â‡„ $changes"
  fi
}

ps-ranger() {
  if (( $+RANGER_LEVEL )); then
    print -n "%F{green}R%f "
  fi
}

ps-aws() {
  local token='ðŸ¯Š' profile
  local age
  if (( $+MFA_ARN )); then
    if [[ -z $AWS_SESSION_TOKEN ]]; then
      token="%B%F{red}$token%f%b"
    elif [[ -n $DYNENV_FILE ]]; then
      age=$(quiet sed -n 's/^unset AWS_SESSION_TOKEN.*# \([[:digit:]]*\)$/\1/p' $DYNENV_FILE)
      if [[ -n $age ]]; then
        if (( $(date +%s) - age > ${MFA_DURATION:-86400} )); then
          token="%F{yellow}$token%f"
        else
          token="%B%F{green}$token%f%b"
        fi
      else
        token="%B%F{yellow}$token%f%b"
      fi
    fi
  else
    token=
  fi
  if [[ -n ${AWS_PROFILE:#default} ]]; then
    profile="â ¶%(!,%B%F{yellow},%B%F{magenta})%10>â€¦>$AWS_PROFILE%>>%f%b"
  fi
  if [[ -n "$token$profile" ]]; then
    print -n "$token$profile "
  fi
}

ps-bufstack() {
  if (( BUFSTACK > 0 )); then
    print -n "â‹®%(!,%F{yellow},%B%F{yellow})$BUFSTACK%f%b "
  fi
}

ps-caret() {
  local caret
  if (( _BAD_INPUT > 0 )); then
    caret="â‰¯"
  else
    caret="Â»"
  fi
  print -n "%(!,%F{red},%F{cyan})${1:-$caret}%f"
}


# Async git status plumbing
# Invokes on every precmd (before the prompt is drawn) plus once every 10 sec
if has git; then
  autoload -Uz add-zsh-hook
  
  ps-git-finished-zle() {
    emulate -L zsh
    local fd=$1
    local head commits changes
    zle -F $fd
    read -ru $fd head
    read -ru $fd commits
    read -ru $fd changes
    exec {fd}<&-
    if [[ $head == $PS_GIT_HEAD
      && $commits == $PS_GIT_COMMITS
      && $changes == $PS_GIT_CHANGES ]]; then
      return
    fi
    PS_GIT_HEAD=$head
    PS_GIT_COMMITS=$commits
    PS_GIT_CHANGES=$changes
    if zle && [[ $CONTEXT == 'start' ]]; then
      zle reset-prompt
    fi
  }
  zle -N ps-git-finished-zle
  
  ps-git-dispatch() {
    emulate -L zsh
    local fd
    exec {fd}< <( ps-git-async )
    command true  # https://www.zsh.org/mla/workers/2018/msg00966.html
    zle -Fw $fd ps-git-finished-zle
  }
  add-zsh-hook precmd ps-git-dispatch
  
  TMOUT=10
  trap ps-git-dispatch ALRM
  
  ps-git-clear() {
    # Otherwise old prompt shows up for a few frames
    unset PROMPT_GITINFO
  }
  add-zsh-hook chpwd ps-git-clear
fi
