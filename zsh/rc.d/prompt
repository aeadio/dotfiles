#!/usr/bin/env zsh
# vim: ft=sh ts=2 sw=2 et:

() {
  # user@host:dir (gitbranch) %awsprofile
  # Â» 
  local ps1=(
    $'\n'  # Start with newline for some padding between commands
    
    '%(!,%F{red},%F{cyan})%n%f'   # Username, colored red if root, else cyan
    '@$(_prompt_host)'
    ':$(_prompt_directory)'
    '$(_prompt_aws)'
    '$(_prompt_gitinfo)'
    
    $'\n'
    
    '$(_prompt_chevron)'
  )
  
  # Â» 
  local ps2=( '$(_prompt_chevron)' )
  
  # ?
  local ps3=( '%(!,%F{red},%F{cyan})?%f ' )
  
  # function:linenum @ file:linenum
  # â†’ details
  # Indent by 2 spaces for each execution depth
  local ps4=(
    $'\n'
    '${(pl[${(%):-%e}+1][  ])}'
    '%N:%i @ %x:%I'
    $'\n'
    '${(pl[${(%):-%e}+1][  ])}'
    'â†’ '
  )
  
  # Build prompts from arrays
  setopt prompt_subst
  for i in {1..4}; do
    eval -- "PS$i=\"\${(j::)ps$i}\""
    eval -- "RPS$i=\"\${(j::)rps$i}\""
  done
}

# Functions for generating prompt content
_prompt_host() {
  if (( $+SSH_CLIENT || $+SSH_TTY )); then
    print -n '%F{green}%M%f'
  else
    print -n '%B%F{magenta}%m%f%b'
  fi
}

_prompt_directory() {
  local fullpath=${(%):-%~}
  local final=${(%):-%1d}
  local components=$(( ${#fullpath//[^\/]/} + 1 ))
  local maxwidth=$(( $COLUMNS / 2 ))
  local display='%~'
  if (( $#fullpath > $maxwidth && $components > 1 )); then
    if (( $#final + 2 >= $maxwidth )); then
      display="â€¦/%1d"
    else
      case $components in
        2) display='â€¦/%1d' ;;
        3) display='%-1~/â€¦/%1d' ;;
        *) display='%-1~/â€¦/%2d' ;;
      esac
    fi
  fi
  if (( ${#${(%)display}} > $maxwidth )); then
    display="$display"$'\n'
  else
    display="$display "
  fi
  print -n "%B%F{blue}$display%f%b"
}

_prompt_gitinfo() {
  # PROMPT_GITINFO is populated by _prompt_gitinfo_async (see zsh/functions/)
  # asynchronously (see below)
  if [[ -n $PROMPT_GITINFO ]]; then
    print -n "$PROMPT_GITINFO "
  fi
}

_prompt_aws() {
  local token profile
  local age
  if (( $+MFA_ARN )); then
    if [[ -z $AWS_SESSION_TOKEN ]]; then
      token='%B%F{red}ðŸ¯Š%f%b'
    elif [[ -n $DYNENV_FILE ]]; then
      age=$(quiet sed -n 's/^unset AWS_SESSION_TOKEN.*# \([[:digit:]]*\)$/\1/p' $DYNENV_FILE)
      if [[ -n $age ]]; then
        if (( $(date +%s) - age > ${MFA_DURATION:-86400} )); then
          token='%F{yellow}ðŸ¯Š%f'
        else
          token='%B%F{green}ðŸ¯Š%f%b'
        fi
      else
        token='%B%F{yellow}ðŸ¯Š%f%b'
      fi
    fi
  fi
  if [[ -n ${AWS_PROFILE:/default/} ]]; then
    profile="â ¶%B%F{magenta}${AWS_PROFILE:/default/}%f%b"
  fi
  if [[ -n "$token$profile" ]]; then
    print -n "$token$profile "
  fi
}

_prompt_chevron() {
  local chevron
  if (( $+RANGER_LEVEL )); then
    chevron="Râ€º"
  else
    chevron="Â»"
  fi
  if (( _BAD_INPUT > 0 )); then
    printf -- ${1:-%s} "%(!,%F{magenta},%F{red})$chevron%f "
  else
    printf -- ${1:-%s} "%(!,%F{red},%F{cyan})$chevron%f "
  fi
}

# Async git status plumbing
# Invokes on every precmd (before the prompt is drawn) plus once every 10 sec
if has git; then
  autoload -Uz add-zsh-hook
  
  _prompt_gitinfo_finished_zle() {
    emulate -L zsh
    local fd=$1
    local result
    zle -F $fd
    read -ru $fd result
    exec {fd}<&-
    if [[ $result == $PROMPT_GITINFO ]]; then
      return
    fi
    PROMPT_GITINFO=$result
    if zle && [[ $CONTEXT == 'start' ]]; then
      zle .reset-prompt
    fi
  }
  zle -N _prompt_gitinfo_finished_zle
  
  _prompt_gitinfo_invoke() {
    emulate -L zsh
    local fd
    exec {fd}< <( _prompt_gitinfo_async )
    command true  # https://www.zsh.org/mla/workers/2018/msg00966.html
    zle -Fw $fd _prompt_gitinfo_finished_zle
  }
  add-zsh-hook precmd _prompt_gitinfo_invoke
  
  TMOUT=10
  trap _prompt_gitinfo_invoke ALRM
  
  _prompt_gitinfo_clear() {
    # Otherwise old prompt shows up for a few frames
    unset PROMPT_GITINFO
  }
  add-zsh-hook chpwd _prompt_gitinfo_clear
fi
