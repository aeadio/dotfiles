#!/usr/bin/env zsh
# vim: ft=sh ts=2 sw=2 et:

() {
  # user@host:dir (gitbranch) %awsprofile
  # Â» 
  local ps1=(
    # For some padding between commands
    $'\n'
    
    # Username
    # Colored red if root, else cyan
    '%(!,%F{red},%F{cyan})%n%f'
    
    '$(_prompt_host "@%s")'
    
    # Directory
    ':%B%F{blue}%~%f%b'
    
    '$(_prompt_gitinfo    " %s")'
    '$(_prompt_awsmfa     " %s")'
    '$(_prompt_awsprofile " â ¶%s")'
    
    $'\n'
    
    '$(_prompt_chevron "%s ")'
  )
  
  # Â» 
  local ps2=( '$(_prompt_chevron "%s ")' )
  
  # ?
  local ps3=( '%(!,%F{red},%F{cyan})?%f ' )
  
  # function:linenum @ file:linenum
  # â†’ details
  # Indent by 2 spaces for each execution depth
  local ps4=(
    $'\n'
    '${(pl[${(%):-%e}+1][  ])}'
    '%N:%i @ %x:%I'
    $'\n'
    '${(pl[${(%):-%e}+1][  ])}'
    'â†’ '
  )
  
  # Build prompts from arrays
  setopt prompt_subst
  for i in {1..4}; do
    eval -- "PS$i=\"\${(j::)ps$i}\""
    eval -- "RPS$i=\"\${(j::)rps$i}\""
  done
}

# Functions for generating prompt content
_prompt_host() {
  if (( $+SSH_CLIENT || $+SSH_TTY )); then
    printf -- ${1:-%s} '%F{green}%M%f'
  else
    printf -- ${1:-%s} '%B%F{magenta}%m%f%b'
  fi
}

_prompt_gitinfo() {
  # PROMPT_GITINFO is populated by _prompt_gitinfo_async (see zsh/functions/)
  # asynchronously (see below)
  if [[ -n $PROMPT_GITINFO ]]; then
    printf -- ${1:-%s} "$PROMPT_GITINFO"
  fi
}

_prompt_awsprofile() {
  if [[ -n $AWS_PROFILE ]]; then
    printf -- ${1:-%s} "%B%F{magenta}$AWS_PROFILE%f%b"
  fi
}

_prompt_awsmfa() {
  if [[ -z $MFA_ARN ]]; then
    return
  fi
  local good="ðŸ¯Š" expired="ðŸ¯Š" unknown="ðŸ¯Š" bad="ðŸ¯Š"
  if [[ -z $AWS_SESSION_TOKEN ]]; then
    printf -- ${1:-%s} "%B%F{red}$bad%f%b"
    return
  fi
  local age
  if [[ -n $DYNENV_FILE ]]; then
    age=$(quiet sed -n 's/^unset AWS_SESSION_TOKEN.*# \([[:digit:]]*\)$/\1/p' $DYNENV_FILE)
  fi
  if [[ -z $age ]]; then
    printf -- ${1:-%s} "%B%F{yellow}$unknown%f%b"
    return
  fi
  if (( $(date +%s) - age > ${MFA_DURATION:-86400} )); then
    printf -- ${1:-%s} "%F{yellow}$expired%f"
  else
    printf -- ${1:-%s} "%B%F{green}$good%f%b"
  fi
}

_prompt_chevron() {
  local chevron
  if (( $+RANGER_LEVEL )); then
    chevron="Râ€º"
  else
    chevron="Â»"
  fi
  if (( _BAD_INPUT > 0 )); then
    printf -- ${1:-%s} "%(!,%F{magenta},%F{red})$chevron%f"
  else
    printf -- ${1:-%s} "%(!,%F{red},%F{cyan})$chevron%f"
  fi
}

# Async git status plumbing
# Invokes on every precmd (before the prompt is drawn) plus once every 10 sec
if has git; then
  autoload -Uz add-zsh-hook
  
  _prompt_gitinfo_finished_zle() {
    emulate -L zsh
    local fd=$1
    local result
    zle -F $fd
    read -ru $fd result
    exec {fd}<&-
    if [[ $result == $PROMPT_GITINFO ]]; then
      return
    fi
    PROMPT_GITINFO=$result
    if zle && [[ $CONTEXT == 'start' ]]; then
      zle .reset-prompt
    fi
  }
  zle -N _prompt_gitinfo_finished_zle
  
  _prompt_gitinfo_invoke() {
    emulate -L zsh
    local fd
    exec {fd}< <( _prompt_gitinfo_async )
    command true  # https://www.zsh.org/mla/workers/2018/msg00966.html
    zle -Fw $fd _prompt_gitinfo_finished_zle
  }
  add-zsh-hook precmd _prompt_gitinfo_invoke
  
  TMOUT=10
  trap _prompt_gitinfo_invoke ALRM
  
  _prompt_gitinfo_clear() {
    # Otherwise old prompt shows up for a few frames
    unset PROMPT_GITINFO
  }
  add-zsh-hook chpwd _prompt_gitinfo_clear
fi
