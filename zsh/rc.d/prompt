# vim: ft=sh ts=2 sw=2 et:

# Prompt formats
() {
  # [[user][@host]:]dir [⨕gitbranch[:commits][ ⇄ localchanges]]
  # [R ][🯊[⠶awsprofile] ][⋮stack]» 
  local ps1=(
    $'\n'  # Start with newline for some padding between commands
    '$(ps-basicinfo)'
    '$(ps-directory; ps-git)'
    $'\n'
    '$(ps-promptception)'
    '$(ps-aws)'
    '$(ps-bufstack)'
    '$(ps-caret) '
  )
  
  # [R][🯊[⠶awsprofile]][⋮stack]» 
  local ps2=(
    '$(ps-level)'
    '$(ps-aws)'
    '$(ps-bufstack)'
    '$(ps-caret) '
  )
  
  # ?
  local ps3=( '$(ps-caret "?")' )
  
  # function:linenum @ file:linenum
  # → details
  # Indent by 2 spaces for each execution depth
  local ps4=(
    $'\n'
    '${(pl[${(%):-%e}+1][  ])}'
    '%N:%i @ %x:%I'
    $'\n'
    '${(pl[${(%):-%e}+1][  ])}'
    "${${UTF8_OK:+→ }:->}"
  )
  
  # Build prompts from arrays
  setopt prompt_subst
  for i in {1..4}; do
    eval -- "PS$i=\"\${(j::)ps$i}\""
    eval -- "RPS$i=\"\${(j::)rps$i}\""
  done
}


# Info blocks
ps-basicinfo() {
  unset PROMPT_INFOLEN
  local user host info
  # Username
  # Only show if we've su'd to a user that's out of the ordinary
  if [[ ${(%):-%n} != (a(|nt(|hony(|eadicicco)))|root) ]]; then
    user="%(!,%B%F{red},%F{cyan})%n%f%b"
  fi
  # Hostname
  # Only show if connected to remote host
  if (( $+SSH_CLIENT || $+SSH_TTY )); then
    host='@%(!,%F{yellow},%B%F{magenta})%m%f%b'
  fi
  if [[ -n "$user$host" ]]; then
    info="$user$host:"
    PROMPT_INFOLEN=$(( ${#info} + 1 ))
    print -n $info
  fi
}

ps-directory() {
  local maxwidth=$(( COLUMNS - PROMPT_INFOLEN ))
  if (( maxwidth < 0 )); then
    return
  elif [[ -n $PS_GIT_HEAD ]] && (( maxwidth > 15 )); then
    (( maxwidth = maxwidth >= 120 ? maxwidth - 40 : maxwidth / 3 * 2 ))
  fi
  local fullpath=${(%):-%~}
  local display=$fullpath
  local ellipses=${${UTF8_OK:+…}:-..}
  if (( ${#display} > maxwidth )); then
    # Favor the last components in the path
    # If the first component is '~', always display it
    local components=( ${(s:/:)fullpath} ) pre='/'
    if [[ $components[1] == '~' ]]; then
      components=( $components[2,-1] )
      pre='~/'
    fi
    local n=${#components} npre=${#pre}
    local i rem=$(( maxwidth - npre )) len
    for (( i = n; i > 0; i-- )); do
      len=${#components[$i]}
      if (( rem - len - npre <= ${#ellipses} + 1 )); then
        components[$i]=${(%):-%$(( rem - npre ))<$ellipses<$components[$i]%<<}
        break
      else
        (( rem -= len + 1 ))  # count one for the preceding /
      fi
    done
    if (( --i > 0 )); then
      components[$i]=$ellipses
      for (( --i ; i > 0; i-- )); components[$i]=
    fi
    display="$pre${(j:/:):-${=components}}"
  fi
  PS_DIRLEN=${#display}
  print -n "%(!,%F{magenta},%B%F{blue})$display%f%b"
}

ps-git() {
  local branch=$PS_GIT_HEAD commits=$PS_GIT_COMMITS changes=$PS_GIT_CHANGES
  if [[ -z $branch ]]; then
    return
  fi
  local maxsize=$(( COLUMNS - PS_DIRLEN - 1 ))
  if (( maxsize < 4 )); then
    return
  fi
  local invisible='%([BSUbfksu]|([FK]|){*})'
  local lbr=$(( ${#branch} + 1 ))
  local lco=$(( ${#${(S%%)commits//$~invisible/}} + 1 ))
  local lch=$(( ${#${(S%%)changes//$~invisible/}} + 3 ))
  local bsize=$(( maxsize - lco - lch ))
  if (( lbr > bsize )); then
    # If we don't have enough space to show much, elide some portions
    if (( bsize < maxsize / 2 )); then
      changes=
      bsize=$(( maxsize - lco ))
    fi
    if (( bsize < maxsize / 2 )); then
      commits=
      bsize=$maxsize
    fi
    branch="%$bsize<${${UTF8_OK:+…}:-..}<$branch%<<"
  fi
  print -n " ${UTF8_OK:+⨕}%(!,%B%F{red},%B%F{cyan})$branch%f%b"
  if [[ -n $commits ]]; then
    print -n ":$commits"
  fi
  if [[ -n $changes ]]; then
    print -n "${UTF8_OK:+ ⇄} $changes"
  fi
}

ps-promptception() {
  # How deep is our prompt? ((Is it like the ocean?))
  # If ( SHLVL - RANGER_LEVEL ) is over 1, show as a number.
  # If inside ranger, show R, plus ( RANGER_LEVEL ) if > 1.
  local rlvl lvl=${${:-$(( SHLVL - RANGER_LEVEL ))}:#1}
  if (( $+RANGER_LEVEL )); then
    rlvl="%F{green}R${RANGER_LEVEL:#1}%f"
  fi
  if [[ -n "$rlvl$lvl" ]]; then
    print -n "$rlvl${${UTF8_OK:+⁑}:- }%{\e[2m%}%F{cyan}$lvl%f%b "
  fi
}

ps-aws() {
  local token profile
  if (( $+UTF8_OK )); then
    token='🯊'
  else
    token='A'
  fi
  local age
  if (( $+MFA_ARN )); then
    if [[ -z $AWS_SESSION_TOKEN ]]; then
      token="%B%F{red}$token%f%b"
    elif [[ -n $DYNENV_FILE ]]; then
      age=$(quiet sed -n 's/^unset AWS_SESSION_TOKEN.*# \([[:digit:]]*\)$/\1/p' $DYNENV_FILE)
      if [[ -n $age ]]; then
        if (( $(date +%s) - age > ${MFA_DURATION:-86400} )); then
          token="%{\e[2m%}%F{yellow}$token%f%b"
        else
          token="%B%F{green}$token%f%b"
        fi
      else
        token="%F{yellow}$token%f"
      fi
    fi
  else
    token=
  fi
  if [[ -n ${AWS_PROFILE:#default} ]]; then
    profile="${${UTF8_OK:+⠶}:-%}%(!,%F{yellow},%B%F{magenta})%10>${${UTF8_OK:+…}:-..}>$AWS_PROFILE%>>%f%b"
  fi
  if [[ -n "$token$profile" ]]; then
    print -n "$token$profile "
  fi
}

ps-bufstack() {
  if (( BUFSTACK > 0 )); then
    print -n "${${UTF8_OK:+⋮}:-S:}%(!,%{\e[2m%}%F{yellow},%F{yellow})$BUFSTACK%f%b "
  fi
}

ps-caret() {
  local caret
  if (( ! $+UTF8_OK )); then
    caret='>'
  elif (( _BAD_INPUT > 0 )); then
    caret='≯'
  else
    caret='»'
  fi
  print -n "%(!,%F{red},%F{cyan})${1:-$caret}%f"
}


# Async git status plumbing
# Invokes on every precmd (before the prompt is drawn) plus once every 10 sec
if has git; then
  autoload -Uz add-zsh-hook
  
  ps-git-finished-zle() {
    emulate -L zsh
    local fd=$1
    local head commits changes
    zle -F $fd
    read -ru $fd head
    read -ru $fd commits
    read -ru $fd changes
    exec {fd}<&-
    if [[ $head == $PS_GIT_HEAD
      && $commits == $PS_GIT_COMMITS
      && $changes == $PS_GIT_CHANGES ]]; then
      return
    fi
    PS_GIT_HEAD=$head
    PS_GIT_COMMITS=$commits
    PS_GIT_CHANGES=$changes
    if zle && [[ $CONTEXT == 'start' ]]; then
      zle reset-prompt
    fi
  }
  zle -N ps-git-finished-zle
  
  ps-git-dispatch() {
    emulate -L zsh
    local fd
    exec {fd}< <( ps-git-async )
    command true  # https://www.zsh.org/mla/workers/2018/msg00966.html
    zle -Fw $fd ps-git-finished-zle
  }
  add-zsh-hook precmd ps-git-dispatch
  
  #TMOUT=10
  #trap ps-git-dispatch ALRM
  
  ps-git-clear() {
    # Otherwise old prompt shows up for a few frames
    unset PROMPT_GITINFO
  }
  add-zsh-hook chpwd ps-git-clear
fi
