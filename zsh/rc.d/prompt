#!/usr/bin/env zsh
# vim: ft=sh ts=2 sw=2 et:

() {
  # user@host:dir (gitbranch) %awsprofile
  # » 
  local ps1=(
    # For some padding between commands
    $'\n'
    
    # Username
    # Colored red if root, else cyan
    '%(!,%F{red},%F{cyan})%n%f'
    
    '$(_prompt_host "@%s")'
    
    # Directory
    ':%B%F{blue}%~%f%b'
    
    '$(_prompt_gitinfo    " (%s)")'
    '$(_prompt_awsprofile " %%%s")'
    '$(_prompt_ranger     " [%s]")'
    
    $'\n'
    
    '$(_prompt_chevron "%s ")'
  )
  
  # » 
  local ps2=( '$(_prompt_chevron "%s ")' )
  
  # ?
  local ps3=( '%(!,%F{red},%F{cyan})?%f ' )
  
  # function:linenum @ file:linenum
  # → details
  # Indent by 2 spaces for each execution depth
  local ps4=(
    $'\n'
    '${(pl[${(%):-%e}+1][  ])}'
    '%N:%i @ %x:%I'
    $'\n'
    '${(pl[${(%):-%e}+1][  ])}'
    '→ '
  )
  
  # Build prompts from arrays
  setopt prompt_subst
  for i in {1..4}; do
    eval -- "PS$i=\"\${(j::)ps$i}\""
    eval -- "RPS$i=\"\${(j::)rps$i}\""
  done
}

# Functions for generating prompt content
_prompt_host() {
  if (( $+SSH_CLIENT || $+SSH_TTY )); then
    printf -- ${1:-%s} '%F{green}%M%f'
  else
    printf -- ${1:-%s} '%B%F{magenta}%m%f%b'
  fi
}

_prompt_gitinfo() {
  if [[ -n $PROMPT_GITINFO ]]; then
    printf -- ${1:-%s} "%B%F{cyan}$PROMPT_GITINFO%f%b"
  fi
}

_prompt_gitinfo_async() {
  # current branch / hash in detached head
  # commits ahead/behind/diverged
  # inside?: rebase, bisect
  local branch=$(git symbolic-ref -q --short HEAD ||
    git rev-parse --short HEAD) 2>/dev/null
  print -r -- "$branch"  # populates PROMPT_GITINFO, see below
}

_prompt_awsprofile() {
  if [[ -n $AWS_PROFILE && $PWD == $HOME/(Source|src)* ]]; then
    printf -- ${1:-%s} "%F{cyan}$AWS_PROFILE%f"
  fi
}

_prompt_ranger() {
  if (( $+RANGER_LEVEL )); then
    print -n '%F{green}R%f'
  fi
}

_prompt_chevron() {
  if (( _BAD_INPUT > 0 )); then
    printf -- ${1:-%s} '%(!,%F{magenta},%F{red})»%f'
  else
    printf -- ${1:-%s} '%(!,%F{red},%F{cyan})»%f'
  fi
}

# Async git status plumbing
# Invokes on every precmd (before the prompt is drawn) plus once every 10 sec
if has git; then
  _prompt_gitinfo_finished_zle() {
    emulate -LR zsh -o prompt_subst
    local fd=$1
    local result
    zle -F $fd
    read -ru $fd result
    exec {fd}<&-
    if [[ $result == $PROMPT_GITINFO ]]; then
      return
    fi
    PROMPT_GITINFO=$result
    if zle && [[ $CONTEXT == 'start' ]]; then
      zle .reset-prompt
    fi
  }
  zle -N _prompt_gitinfo_finished_zle

  _prompt_gitinfo_invoke() {
    emulate -LR zsh
    local fd
    exec {fd}< <( _prompt_gitinfo_async )
    command true  # https://www.zsh.org/mla/workers/2018/msg00966.html
    zle -Fw $fd _prompt_gitinfo_finished_zle
  }
  autoload -Uz add-zsh-hook
  add-zsh-hook precmd _prompt_gitinfo_invoke

  TMOUT=10
  trap _prompt_gitinfo_invoke ALRM
fi
